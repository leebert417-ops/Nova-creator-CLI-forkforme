# 模块1.0：变量结构设计（Zod脚本）

## 模块定义

本模块是 MVU 系统的第一步，负责通过 Zod schema 定义变量的结构、类型和验证规则。

**核心功能**：
- 使用 Zod 4.x 定义变量结构
- 提供类型安全和运行时验证
- 支持增量更新和幂等操作
- 为后续的变量初始化和更新提供结构约束

**重要说明**：
- 此模块在传统 MVU 初始化之前执行
- 定义的 schema 将用于验证所有变量更新操作
- 支持复杂的嵌套结构和自定义验证逻辑

---

## 生成任务

根据项目需求，使用 Zod 4.x 定义变量结构的 schema，生成完整的 JavaScript 脚本文件。

---

## Zod Schema 设计规范

### 可用的库

**重要说明**：`z`（来自 Zod）和 `_`（来自 Lodash）默认可用，可以直接使用，无需再次导入。

```js
// ✅ 正确：直接使用
好感度: z.coerce.number().transform(v => _.clamp(v, -100, 100))

// ❌ 错误：不要重复导入
import _ from 'lodash';  // 不需要
import { z } from 'zod'; // 不需要
```

---

### 幂等操作原则

Schema 设计必须支持增量更新，确保：
```
Schema.parse(Schema.parse(input)) === Schema.parse(input)
```

**要点**：
- 谨慎使用 `z.transform`，避免破坏幂等性
- 确保 schema 的输出可以作为自身的有效输入

---

### 类型定义规则

#### 数字类型

**优先使用** `z.coerce.number()`：
```js
// 推荐：自动转换字符串数字
好感度: z.coerce.number()

// 不推荐：无法处理字符串输入
好感度: z.number()
```

**注意**：仅对数字使用 `z.coerce.xxx()`，其他类型直接使用基础类型（如 `z.boolean()`、`z.string()`）

---

#### 对象结构优于数组

**推荐方式**（使用 record）：
```js
物品栏: z.record(
  z.string().describe('物品名'),
  z.object({
    描述: z.string(),
    数量: z.coerce.number()
  })
)
```

**不推荐**（使用 array）：
```js
物品栏: z.array(z.object({
  名称: z.string(),
  描述: z.string(),
  数量: z.coerce.number()
}))
```

**原因**：数组索引难以理解和维护，使用对象键（如物品名）更直观

---

#### 对象 Schema 的选择策略

根据对象的键特征选择合适的 schema 类型：

**1. 固定必需键 + 相同类型**
```js
z.record(
  z.enum(['key1', 'key2', ...]),
  z.string()  // 统一的值类型
)
```

**2. 动态可选键 + 相同类型**
```js
z.record(z.string(), z.coerce.number())
```

**3. 固定必需键 + 不同类型**
```js
z.object({
  key1: z.string(),
  key2: z.coerce.number(),
  ...
})
```

**4. 部分必需键 + 动态可选键 + 相同类型**
```js
z.intersection(
  z.object({
    requiredKey1: z.string(),
    requiredKey2: z.coerce.number()
  }),
  z.record(z.string(), z.string())
)
```

---

#### 可清除对象的处理

对于可能被 JSON patch 清除的对象（`{ "op": "remove", "path": "/path/to/object" }`）：

**推荐**：
```js
z.object({ ... }).prefault({})
```

**不推荐**：
```js
z.object({ ... }).optional()
```

**原因**：`.prefault({})` 对增量更新兼容性更好

---

### 约束与验证规则

#### 容错优先原则

当接收到违反 schema 的更新时，优先使用 `z.transform` 进行修正，而非直接拒绝：

**推荐方式**（自动修正）：
```js
// 值限制在 0-100 之间
好感度: z.coerce.number().transform(value => _.clamp(value, 0, 100))

// 对象键数量限制：超出时删除最旧的键
记忆: z.record(z.string(), z.string()).transform(obj => {
  const entries = Object.entries(obj);
  if (entries.length > 10) {
    return Object.fromEntries(entries.slice(-10));
  }
  return obj;
})
```

**不推荐**（直接拒绝）：
```js
好感度: z.number().min(0).max(100)  // 会抛出错误
```

**重要**：仅在 Explorer（用户）明确要求时才施加这些约束

---

#### 特殊格式处理

对于特殊格式的字符串（如固定模板），优先使用 `z.templateLiteral` 而非正则或手动解析：

**推荐**：
```js
// 例如：时间格式 "HH:MM"
时间: z.templateLiteral([z.string(), ":", z.string()])
```

**不推荐**：
```js
时间: z.string().regex(/^\d{2}:\d{2}$/)
```

**注意**：这种情况较少出现，仅在确实需要时使用

---

### 默认值设置

#### 使用 prefault 而非 default

**推荐**：
```js
z.string().prefault("默认值")
```

**不推荐**：
```js
z.string().default("默认值")
```

**重要**：除非 Explorer 明确要求，否则不要设置任何默认值或施加任何约束

---

### 描述字段的使用

仅在没有字段名来解释 schema 用途时才使用 `z.describe()`，例如 `z.record` 的键类型：

**应该使用 describe**：
```js
物品栏: z.record(
  z.string().describe('物品名'),  // 键没有字段名，需要描述
  z.object({ 描述: z.string() })
)
```

**不应该使用 describe**：
```js
// ❌ 不好：字段名已经说明了用途
好感度: z.coerce.number().describe('好感度数值')

// ✅ 好：字段名已经足够清晰
好感度: z.coerce.number()
```

---

### 避免重复定义

尽可能合并相同的变量 schema，但不要为此定义额外的变量。

**重要限制**：只能在 `export const Schema = z.object({ ... })` 内部定义 schema

**可以接受**（内联合并）：
```js
export const Schema = z.object({
  角色A: z.object({ 好感度: z.coerce.number() }),
  角色B: z.object({ 好感度: z.coerce.number() })
  // 即使重复，也不额外定义变量
});
```

**不推荐**（定义额外变量）：
```js
// ❌ 不要这样做
const 角色Schema = z.object({ 好感度: z.coerce.number() });
export const Schema = z.object({
  角色A: 角色Schema,
  角色B: 角色Schema
});
```

---

## 标准输出格式

### 脚本模板

```js
import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

export const Schema = z.object({
  // 在此定义你的变量结构
  日期: z.string(),
  时间: z.string(),
  user: z.object({
    身份: z.string(),
    当前位置: z.string(),
    好感度: z.coerce.number().transform(v => _.clamp(v, -100, 100))
  }),
  // ... 其他变量
});

$(() => {
  registerMvuSchema(Schema);
})
```

**附加说明**：解释你为什么这样构建 schema，以及该 schema 如何满足需求（用简体中文）

---

## 示例参考

**注意**：以下示例仅供参考，实际应根据项目需求定义变量结构。

```js
import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

export const Schema = z.object({
  日期: z.string(),
  时间: z.string(),

  user: z.object({
    身份: z.string(),
    当前位置: z.string(),
    重要经历: z.string(),
    好感度: z.coerce.number().transform(v => _.clamp(v, -100, 100))
  }),

  理: z.object({
    当前位置: z.string(),
    情绪状态: z.object({
      pleasure: z.coerce.number().transform(v => _.clamp(v, -1, 1)),
      arousal: z.coerce.number().transform(v => _.clamp(v, -1, 1))
    }),
    当前所想: z.string()
  }),

  世界: z.object({
    当前事件阶段: z.coerce.number(),
    天气: z.string()
  }),

  物品栏: z.record(
    z.string().describe('物品名'),
    z.object({
      描述: z.string(),
      数量: z.coerce.number()
    })
  ).prefault({})
});

$(() => {
  registerMvuSchema(Schema);
})
```

**设计说明**：
- 使用 `z.coerce.number()` 确保数字类型可以接受字符串形式的数字输入
- `好感度` 和 `pleasure`/`arousal` 使用了 `transform` 配合 `_.clamp()` 自动限制范围，避免直接拒绝超出范围的输入
- `物品栏` 使用 `record` 而非数组，便于通过物品名直接访问，索引更直观
- `物品栏` 使用 `prefault({})` 而非 `optional()`，表示该对象可以被 JSON patch 清空，同时对增量更新有更好的兼容性
- 物品栏的键使用 `z.string().describe('物品名')` 提供描述，因为 record 的键类型没有字段名
- 仅对明确需要约束的字段（如好感度范围）添加了 transform，其他字段保持灵活

---

## 输出要求

### 1. 主体内容

生成完整的 JavaScript 脚本文件，包含：
- 必要的 import 语句
- 完整的 Schema 定义
- 注册 schema 的初始化代码

### 2. 设计原则确认

确保生成的 schema：
- 符合幂等操作要求（`Schema.parse(Schema.parse(input))` === `Schema.parse(input)`）
- 数字类型使用 `z.coerce.number()`
- 优先使用对象（record）而非数组
- 仅在 Explorer 明确要求时添加约束和默认值
- 使用 `z.transform` 进行容错处理（如需要）
- 仅在必要时使用 `z.describe()`（如 record 的键类型）
- 不要定义额外变量，所有 schema 定义在 `export const Schema = z.object({ ... })` 内部

### 3. 附加说明

生成脚本后，提供以下说明：

#### a. 设计说明（简体中文）

用简体中文解释：
- 为什么这样构建 schema（整体结构设计思路）
- 关键字段的类型选择理由
- 如何满足项目需求
- 如果使用了特殊的验证规则或约束，说明其用途和实现方式（如 transform 的作用）

#### b. 与其他模块的关系

"此 schema 脚本将用于验证所有变量更新操作，应与模块1.1/1.2（变量初始化）、模块2（变量更新规则）和模块3（变量处理指令集）配合使用。"

---

## 生成指令

生成内容后，使用 Write 工具将脚本代码保存到 `变量结构.js` 文件中。

---

## 使用说明

### 与其他模块的关系

- **模块1.1/1.2**（变量初始化）：使用此 schema 验证初始值
- **模块2**（变量更新规则）：更新规则应符合此 schema 定义
- **模块3**（变量处理指令集）：更新命令会被此 schema 验证

---

## 重要提醒

**约束和默认值**：
- **重复强调**：仅在 Explorer 明确要求时才添加验证约束
- **重复强调**：仅在 Explorer 明确要求时才设置默认值（使用 `z.prefault`）
- 优先使用 `z.transform` 进行容错处理，而非直接拒绝输入
- 当接收到违反约束的更新时，用户期望更新能产生某些效果而非完全被丢弃

**幂等性检查**：
- 生成 schema 后，确保 `Schema.parse(Schema.parse(data))` 等于 `Schema.parse(data)`
- 特别注意 `z.transform` 的使用，避免多次解析产生不同结果
